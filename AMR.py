import os
import sys
import time
import importlib
import matplotlib.animation as animation
from GUIBaseClass import GUIBase
from GUIBaseClass import animate_plot

sys.path.append(os.getcwd())  # add path to import dictionary
defaults = importlib.import_module('FieldControls',
                                   os.getcwd())  # import dictionary based on the name of the computer
mag_settings = getattr(defaults, os.environ.get('USERNAME'))
res_settings = getattr(defaults, os.environ.get('USERNAME') + '_RESOURCES')


# set Hx field, wait for delay
def fix_param1(index, output, delay, resources, kwargs):
    if index == 0:
        resources['keithley_2000'].auto_range()
        resources['keithley_2000'].mode = 'voltage'
        r1 = measure_resistance()  # check the device resistance
        print(r1)
        resources['keithley_2400'].apply_current() # sets keithley up to source current
        resources['keithley_2400'].source_current_range = float(kwargs['current stop']) / 1000 # sets source current range in mA
        resources['keithley_2400'].compliance_voltage = int((float(kwargs['current stop']) / 1000) * r1) + 1 # set compliance voltage
        resources['keithley_2400'].enable_source()
    setattr(resources['dsp_lockin'], kwargs['Hz Dac'],
            output / float(kwargs['Hz Conversion']))
    time.sleep(delay)


# set keithley 2400 current, wait for delay
def fix_param2(output, delay, resources, kwargs):
    resources['keithley_2400'].source_current = output * 10e-3  # set to mA


# set Hz field, wait for delay, measure Hz field, measure voltage, take average return resistance
def measure_y(output, delay, resources, fix1_output, fix2_output, kwargs):
    setattr(resources['dsp_lockin'], kwargs['Hx Dac'],
            output / float(kwargs['Hx Conversion']))  # obj, name, value
    time.sleep(delay)
    x2 = resources['gaussmeter'].measure()
    y = 0.0
    for i in range(int(kwargs['averages'])):
        y += resources['keithley_2000'].voltage
    y = (y * 1000 / int(kwargs['averages'])) / fix2_output
    return float(output), float(y), x2


def main():  # test version of the GUI_base and animation
    # test dictionary for settings
    resource_dict = {
        'dsp_lockin': res_settings['dsp_lockin'],
        'keithley_2000': res_settings['keithley_2000'],
        'keithley_2400': res_settings['keithley_2400'],
        'gaussmeter': res_settings['gaussmeter'],
    }

    graph_dict = {
        # i.e. AHE Measurement (should be the measurement type)
        "gui_title": 'AMR Measurement',
        "graph_title": "Resistance (Ohm) vs Hx (Oe)",  # Resistance vs. Hx
        "x_title": "Applied Field (Oe)",  # i.e. Applied Field (Oe)
        "y_title": "Realtime Resistance (Ohm)",  # i.e. Hall Resistance (Ohm)
        # for gaussmeter readings, leave blank if no gaussmeter used
        "x2_title": "Gaussmeter (Oe)",
        "fixed_param_1": "Hz Field (Oe)",  # i.e. Hx 100 (Oe)
        "fixed_param_2": "Current (mA)"  # i.e. Current 1.9 (mA)
    }

    loop_commands = {
        'fixed_func_1': 'fix_param1',  # name of fixed parameter one function
        'fixed_func_2': 'fix_param2',
        'measure_y_func': 'measure_y',
        # directory from which the preceeding modules will be imported from
        'module_path': os.getcwd(),
        # name of the file to get the functions from
        'module_name': 'AMR',
        'fix1_start': 'hz start',
        'fix1_stop': 'hz stop',
        'fix1_step': 'hz step',
        'fix2_start': 'current start',
        'fix2_stop': 'current stop',
        'fix2_step': 'current step',
        'x_start': 'hx start',
        'x_stop': 'hx stop',
        'x_step': 'hx step',
        'MOKE': False
    }

    """
    The following dictionaries are passed in as *args, meaning there can be a variable number.  The key,value combos
    for each individual dictionary are autogenerated in the GUIBaseClass and the value becomes a corresponding tkinter widgit.
    These key,value combos are then passed to the measurement class when the measure button is pressed (note that values are passed
    as value.get()).  The arrays generated for the three measurement for loops are set by the loop commands dictionary above.
    """

    controls_dict1 = {
        "title": "Magnet Controls",
        "hx start": -100,
        "hx stop": 100,
        "hx step": 5,
        "hz start": 0,
        "hz stop": 0,
        "hz step": 0,
    }

    controls_dict2 = {
        "title": "Current Controls",
        "current start": -1.9,
        "current stop": 1.9,
        "current step": 0,
        'averages': 1
    }

    lockin_controls = {
        "title": "Lockin",
        'Hx Dac': mag_settings['Hx Dac'],
        'Hz Dac': mag_settings['Hz Dac'],
        'Hx Conversion': mag_settings['Hx Conversion'],
        'Hz Conversion': mag_settings['Hz Conversion'],
        'Hx Max': mag_settings['Hx Max'],
        'Hz Max': mag_settings['Hz Max']
    }

    """
    Below are the three lines of code that create an instance of the GUIBase, animation function
    and then start the GUIBase.
    """

    measurement_gui = GUIBase(graph_dict,
                              resource_dict,
                              loop_commands,
                              controls_dict1,
                              controls_dict2,
                              lockin_controls)
    ani = animation.FuncAnimation(
        measurement_gui.fig, animate_plot, interval=200, fargs=[measurement_gui.ax,
                                                                measurement_gui.graph,
                                                                measurement_gui.results,
                                                                measurement_gui.progress_bar,
                                                                measurement_gui.time_var])
    measurement_gui.mainloop()


if __name__ == '__main__':
    main()
